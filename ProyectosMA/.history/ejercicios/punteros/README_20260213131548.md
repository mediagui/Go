# Proyecto Punteros - PatrÃ³n Puertos y Adaptadores (Hexagonal Architecture)

## ğŸ“‹ DescripciÃ³n General

Este proyecto es una demostraciÃ³n educativa del **patrÃ³n de arquitectura hexagonal (puertos y adaptadores)** implementado en Go. El objetivo es mostrar cÃ³mo estructurar una aplicaciÃ³n con clara separaciÃ³n de responsabilidades, facilitar el testing unitario mediante interfaces y aplicar **inyecciÃ³n de dependencias**.

## ğŸ—ï¸ Arquitectura del Proyecto

```
punteros/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ main.go                 # Punto de entrada y orquestaciÃ³n de dependencias
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ adapters/               # Implementaciones concretas (adaptadores externos)
â”‚   â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”‚   â””â”€â”€ task_handler.go # Adaptador: Controlador HTTP/API
â”‚   â”‚   â””â”€â”€ repository/
â”‚   â”‚       â””â”€â”€ task_repository.go # Adaptador: Persistencia en memoria
â”‚   â””â”€â”€ core/                   # NÃºcleo de la aplicaciÃ³n (lÃ³gica de negocio)
â”‚       â”œâ”€â”€ domain/             # Entidades y modelos de dominio
â”‚       â”‚   â”œâ”€â”€ task.go         # DefiniciÃ³n de la entidad Task
â”‚       â”‚   â””â”€â”€ taskStatus.go   # Estados posibles de una tarea
â”‚       â”œâ”€â”€ ports/              # Interfaces (puertos) que definen contratos
â”‚       â”‚   â””â”€â”€ ports.go        # DefiniciÃ³n de interfaces
â”‚       â””â”€â”€ service/            # Casos de uso (lÃ³gica de negocio)
â”‚           â””â”€â”€ task_service.go # Servicio que orquesta la lÃ³gica
â””â”€â”€ go.mod                      # Archivo de mÃ³dulo Go
```

## ğŸ¯ Conceptos Clave

### 1. **PatrÃ³n Hexagonal (Puertos y Adaptadores)**

La arquitectura hexagonal divide la aplicaciÃ³n en tres capas concÃ©ntricas:

```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚      MUNDO EXTERNO               â”‚
           â”‚  (HTTP, Bases de Datos, etc)   â”‚
           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   ADAPTADORES â”‚
          â”‚   (HTTP, DB)  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚    PUERTOS (INTERFACES)    â”‚
          â”‚  TaskRepository            â”‚
          â”‚  TaskService               â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  NÃšCLEO / DOMINIO â”‚
         â”‚  - Task Entity    â”‚
         â”‚  - TaskStatus     â”‚
         â”‚  - LÃ³gica Negocio â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. **InyecciÃ³n de Dependencias (DI)**

La inyecciÃ³n de dependencias permite que:
- Los componentes **no crean sus propias dependencias**, las reciben como parÃ¡metros
- Las dependencias se **inyectan en tiempo de construcciÃ³n** (en `main.go`)
- Facilitamos **testing unitario** reemplazando dependencias por mocks

**Ejemplo en el proyecto:**
```go
// En main.go, inyectamos explÃ­citamente las dependencias
taskRepository := repository.NewTaskRepository()
taskService := service.NewTaskService(taskRepository)  // Inyectamos el repository
taskHandler := http.NewTaskHandler(taskService)         // Inyectamos el service
```

### 3. **InversiÃ³n de Control (IoC)**

Las dependencias **apuntan siempre hacia el nÃºcleo**, no hacia fuera:
- `TaskHandler` depende de la **interfaz** `TaskService` (puerto)
- `TaskService` depende de la **interfaz** `TaskRepository` (puerto)
- Las implementaciones concretas (`TaskHandler`, `TaskService`) estÃ¡n en adaptadores
- El dominio **nunca depende de nada**, es independiente

## ğŸ“ Estructura Detallada por Carpeta

### **`cmd/main.go`** - Punto de Entrada
- **Responsabilidad**: Orquestar la aplicaciÃ³n e inyectar dependencias
- **QuÃ© hace**:
  1. Crea instancia del repositorio (adaptador)
  2. Crea instancia del servicio, inyectando el repositorio
  3. Crea instancia del handler, inyectando el servicio
  4. Ejecuta operaciones de prueba (CRUD)

### **`internal/core/domain/`** - Dominio (NÃºcleo del Negocio)

#### `task.go`
- **Struct privado `task`**: Encapsula los datos internos
- **Tipo pÃºblico `TaskType`**: Interfaz pÃºblica para trabajar con tareas
- **Campos**: `Id`, `Title`, `Description`, `Status`

#### `taskStatus.go`
- **Enum pseudo-tipo** usando `const` y valores de `iota`
- **Estados**: `Completed` (0) y `Uncompleted` (1)
- **MÃ©todos**: `String()` y `IsCompleted()` para utilidad

### **`internal/core/ports/`** - Puertos (Interfaces)

#### `ports.go`
Define dos **interfaces principales**:

1. **`TaskRepository`**: Puerto para persistencia
   - MÃ©todos: `FindById()`, `Add()`, `Update()`, `Delete()`, `FindAll()`
   - Separa la lÃ³gica de negocio de cÃ³mo se almacenan datos

2. **`TaskService`**: Puerto para la lÃ³gica de negocio
   - MÃ©todos: `FindByIdTask()`, `AddTask()`, `UpdateTask()`, `DeleteTask()`, `FindAllTask()`
   - Define el contrato que cualquier implementaciÃ³n debe cumplir

### **`internal/core/service/`** - Servicios (LÃ³gica de Negocio)

#### `task_service.go`
- **Implementa** la interfaz `TaskService`
- **Campo privado**: `repository` de tipo `TaskRepository` (interfaz, no implementaciÃ³n)
- **PatrÃ³n**: Delega operaciones al repositorio sin conocer cÃ³mo se persisten
- **Constructor `NewTaskService()`**: Inyecta el repositorio mediante parÃ¡metro

### **`internal/adapters/`** - Adaptadores (Implementaciones Concretas)

#### `repository/task_repository.go`
- **Implementa** la interfaz `TaskRepository`
- **Estructura**: `inMemoryTaskRepository` con `map[uint8]domain.TaskType`
- **Almacenamiento**: Usa mapa en memoria (sin base de datos)
- **MÃ©todos**: ImplementaciÃ³n concreta de persistencia
- **Constructor `NewTaskRepository()`**: Retorna la interfaz `TaskRepository`

#### `http/task_handler.go`
- **Implementa** adaptador HTTP (controlador)
- **Campo privado**: `service` de tipo `TaskService` (interfaz)
- **MÃ©todos**: Mapean operaciones de la aplicaciÃ³n a endpoints lÃ³gicos
- **Constructor `NewTaskHandler()`**: Inyecta el servicio

## ğŸ”„ Flujo de Datos

```
main.go
   â†“
TaskHandler (Adaptador HTTP)
   â†“ (usa interfaz TaskService)
TaskService (LÃ³gica de Negocio)
   â†“ (usa interfaz TaskRepository)
TaskRepository (Adaptador de Persistencia)
   â†“
Datos (Map en memoria)
```

**Ventajas de este flujo**:
- Cada capa es **independiente**
- Cambiar la persistencia **no afecta** la lÃ³gica de negocio
- Testing es **fÃ¡cil**: reemplaza adaptadores con mocks
- CÃ³digo es **mantenible y escalable**

## ğŸ’¡ Beneficios del PatrÃ³n

| Concepto | Beneficio |
|----------|-----------|
| **Puertos** | Definen contratos claros entre capas |
| **Adaptadores** | Implementaciones intercambiables |
| **DI** | CÃ³digo desacoplado y testeable |
| **Dominio Independiente** | LÃ³gica de negocio aislada de detalles tÃ©cnicos |
| **SeparaciÃ³n de Responsabilidades** | Cada componente tiene un Ãºnico propÃ³sito |

## ğŸ§ª Ejemplo de Testing

Con este patrÃ³n, testing es sencillo:

```go
// Mock del repositorio para tests
type MockRepository struct{}

func (m *MockRepository) FindById(id uint8) (domain.TaskType, error) {
    return domain.TaskType{Id: id, Title: "Test"}, nil
}
// ... implementar otras funciones

// En el test
mockRepo := &MockRepository{}
service := service.NewTaskService(mockRepo)  // Inyectar mock
// Verificar comportamiento sin base de datos real
```

## ğŸš€ CÃ³mo Ejecutar

```bash
# Desde la carpeta punteros
go run ./cmd/main.go
```

**Salida esperada**:
- CreaciÃ³n de tareas
- Listado de tareas
- ActualizaciÃ³n de tarea
- EliminaciÃ³n de tarea
- Listado final actualizado

## ğŸ“š Conceptos Go Utilizados

- **Interfaces** (`TaskRepository`, `TaskService`)
- **Constructores** (`NewTaskService`, `NewTaskRepository`, `NewTaskHandler`)
- **Punteros y Receptores** (`*TaskService`, `*TaskHandler`)
- **MÃ©todos** (implementaciÃ³n de interfaces)
- **EncapsulaciÃ³n** (campos privados/pÃºblicos)
- **Maps** (almacenamiento en memoria)
- **Constants y Enums** (`TaskStatus`)

## ğŸ“ Lecciones Aprendidas

1. **DiseÃ±o por Interfaces**: Las interfaces permiten desacoplamiento
2. **InversiÃ³n de Control**: La aplicaciÃ³n controla las dependencias, no al revÃ©s
3. **Single Responsibility**: Cada archivo/funciÃ³n tiene un propÃ³sito Ãºnico
4. **Hexagonal Architecture**: Aisla la lÃ³gica de negocio de detalles tÃ©cnicos
5. **Go IdiomÃ¡tico**: Constructores que retornan interfaces, no implementaciones

## ğŸ“– Referencias

- Hexagonal Architecture: https://alistair.cockburn.us/hexagonal-architecture/
- Go Interfaces: https://golang.org/doc/effective_go#interfaces
- Dependency Injection: https://martinfowler.com/articles/injection.html

---

**Autor**: Proyecto educativo de arquitectura en Go  
**VersiÃ³n Go**: 1.26.0  
**PatrÃ³n**: Hexagonal Architecture (Puertos y Adaptadores)
